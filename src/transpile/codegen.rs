//! Code generation for Apex to TypeScript transpilation

use super::context::RUNTIME_INTERFACE;
use super::error::TranspileError;
use super::TranspileOptions;
use crate::ast::{
    AccessModifier, AssignmentOp, BinaryOp, Block, ClassDeclaration, ClassMember, CompilationUnit,
    ConstructorDeclaration, DmlOperation, DmlStatement, DoWhileStatement, EnumDeclaration,
    Expression, FieldDeclaration, ForEachStatement, ForInit, ForStatement, IfStatement,
    InterfaceDeclaration, InterfaceMember, LocalVariableDeclaration, MethodDeclaration,
    PropertyDeclaration, SelectField, SoqlQuery, Statement, SwitchStatement, TriggerDeclaration,
    TriggerEvent, TryStatement, TypeDeclaration, TypeRef, UnaryOp, WhenValue, WhileStatement,
};

/// Transpiler converts Apex AST to TypeScript/JavaScript
pub struct Transpiler {
    options: TranspileOptions,
    output: String,
    indent_level: usize,
    /// Track if current method needs to be async (contains SOQL/DML)
    needs_async: bool,
    /// Current class name for static field resolution
    current_class: Option<String>,
    /// Static fields in current class
    static_fields: std::collections::HashSet<String>,
}

impl Transpiler {
    pub fn new() -> Self {
        Self::with_options(TranspileOptions::default())
    }

    pub fn with_options(options: TranspileOptions) -> Self {
        Self {
            options,
            output: String::new(),
            indent_level: 0,
            needs_async: false,
            current_class: None,
            static_fields: std::collections::HashSet::new(),
        }
    }

    /// Transpile a compilation unit to TypeScript
    pub fn transpile(&mut self, unit: &CompilationUnit) -> Result<String, TranspileError> {
        self.output.clear();

        // Add header
        if self.options.include_imports {
            self.emit_header();
        }

        // Transpile each declaration
        for decl in &unit.declarations {
            self.transpile_declaration(decl)?;
            self.newline();
        }

        Ok(self.output.clone())
    }

    fn emit_header(&mut self) {
        self.writeln("// Generated by ApexRust Transpiler");
        self.writeln("// Do not edit directly");
        self.newline();

        if self.options.typescript {
            self.writeln(RUNTIME_INTERFACE);
            self.newline();
        }
    }

    // ========================================================================
    // Declaration transpilation
    // ========================================================================

    fn transpile_declaration(&mut self, decl: &TypeDeclaration) -> Result<(), TranspileError> {
        match decl {
            TypeDeclaration::Class(class) => self.transpile_class(class),
            TypeDeclaration::Interface(iface) => self.transpile_interface(iface),
            TypeDeclaration::Enum(enum_decl) => self.transpile_enum(enum_decl),
            TypeDeclaration::Trigger(trigger) => self.transpile_trigger(trigger),
        }
    }

    fn transpile_class(&mut self, class: &ClassDeclaration) -> Result<(), TranspileError> {
        // Export modifier
        let export = if class.modifiers.access == AccessModifier::Public {
            "export "
        } else {
            ""
        };

        // Class declaration
        let abstract_mod = if class.modifiers.is_abstract {
            "abstract "
        } else {
            ""
        };

        self.write(&format!("{}{}class {}", export, abstract_mod, class.name));

        // Extends
        if let Some(ref extends) = class.extends {
            self.write(&format!(" extends {}", self.type_ref_to_ts(extends)));
        }

        // Implements
        if !class.implements.is_empty() {
            let impls: Vec<String> = class
                .implements
                .iter()
                .map(|t| self.type_ref_to_ts(t))
                .collect();
            self.write(&format!(" implements {}", impls.join(", ")));
        }

        self.writeln(" {");
        self.indent();

        // Track current class and collect static fields
        let old_class = self.current_class.take();
        let old_static_fields = std::mem::take(&mut self.static_fields);

        self.current_class = Some(class.name.clone());

        // First pass: collect static field names
        for member in &class.members {
            if let ClassMember::Field(field) = member {
                if field.modifiers.is_static {
                    for declarator in &field.declarators {
                        self.static_fields.insert(declarator.name.clone());
                    }
                }
            }
        }

        // Transpile members
        for member in &class.members {
            self.transpile_class_member(member)?;
        }

        // Restore previous context
        self.current_class = old_class;
        self.static_fields = old_static_fields;

        self.dedent();
        self.writeln("}");

        Ok(())
    }

    fn transpile_class_member(&mut self, member: &ClassMember) -> Result<(), TranspileError> {
        match member {
            ClassMember::Field(field) => self.transpile_field(field),
            ClassMember::Method(method) => self.transpile_method(method),
            ClassMember::Constructor(ctor) => self.transpile_constructor(ctor),
            ClassMember::Property(prop) => self.transpile_property(prop),
            ClassMember::StaticBlock(block) => self.transpile_static_block(block),
            ClassMember::InnerClass(class) => self.transpile_class(class),
            ClassMember::InnerInterface(iface) => self.transpile_interface(iface),
            ClassMember::InnerEnum(enum_decl) => self.transpile_enum(enum_decl),
        }
    }

    fn transpile_field(&mut self, field: &FieldDeclaration) -> Result<(), TranspileError> {
        let access = self.access_modifier_to_ts(&field.modifiers.access);
        let static_mod = if field.modifiers.is_static {
            "static "
        } else {
            ""
        };
        let readonly = if field.modifiers.is_final {
            "readonly "
        } else {
            ""
        };
        let ts_type = self.type_ref_to_ts(&field.type_ref);

        for declarator in &field.declarators {
            self.write_indent();
            self.write(&format!(
                "{}{}{}{}",
                access, static_mod, readonly, declarator.name
            ));

            if self.options.typescript {
                self.write(&format!(": {}", ts_type));
            }

            if let Some(ref init) = declarator.initializer {
                self.write(" = ");
                self.transpile_expression(init)?;
            }

            self.writeln(";");
        }

        Ok(())
    }

    fn transpile_method(&mut self, method: &MethodDeclaration) -> Result<(), TranspileError> {
        // Check if method body contains SOQL/DML
        self.needs_async = false;
        if let Some(ref body) = method.body {
            self.scan_for_async_needs(body);
        }

        let access = self.access_modifier_to_ts(&method.modifiers.access);
        let static_mod = if method.modifiers.is_static {
            "static "
        } else {
            ""
        };
        let abstract_mod = if method.modifiers.is_abstract {
            "abstract "
        } else {
            ""
        };
        let async_mod = if self.needs_async && self.options.async_database {
            "async "
        } else {
            ""
        };

        self.write_indent();
        self.write(&format!(
            "{}{}{}{}{}",
            access, static_mod, abstract_mod, async_mod, method.name
        ));

        // Parameters
        self.write("(");
        let params: Vec<String> = method
            .parameters
            .iter()
            .map(|p| {
                if self.options.typescript {
                    format!("{}: {}", p.name, self.type_ref_to_ts(&p.type_ref))
                } else {
                    p.name.clone()
                }
            })
            .collect();
        self.write(&params.join(", "));
        self.write(")");

        // Return type
        if self.options.typescript {
            let ret_type = self.type_ref_to_ts(&method.return_type);
            if self.needs_async && self.options.async_database {
                self.write(&format!(": Promise<{}>", ret_type));
            } else {
                self.write(&format!(": {}", ret_type));
            }
        }

        // Body
        if let Some(ref body) = method.body {
            self.writeln(" {");
            self.indent();
            self.transpile_block(body)?;
            self.dedent();
            self.write_indent();
            self.writeln("}");
        } else {
            self.writeln(";");
        }

        self.newline();
        Ok(())
    }

    fn transpile_constructor(
        &mut self,
        ctor: &ConstructorDeclaration,
    ) -> Result<(), TranspileError> {
        self.needs_async = false;
        self.scan_for_async_needs(&ctor.body);

        let access = self.access_modifier_to_ts(&ctor.modifiers.access);

        self.write_indent();
        self.write(&format!("{}constructor(", access));

        let params: Vec<String> = ctor
            .parameters
            .iter()
            .map(|p| {
                if self.options.typescript {
                    format!("{}: {}", p.name, self.type_ref_to_ts(&p.type_ref))
                } else {
                    p.name.clone()
                }
            })
            .collect();
        self.write(&params.join(", "));
        self.writeln(") {");

        self.indent();
        self.transpile_block(&ctor.body)?;
        self.dedent();

        self.write_indent();
        self.writeln("}");
        self.newline();

        Ok(())
    }

    fn transpile_property(&mut self, prop: &PropertyDeclaration) -> Result<(), TranspileError> {
        // TypeScript doesn't have direct property syntax like C#/Apex
        // We'll generate getter/setter methods or use class fields

        let access = self.access_modifier_to_ts(&prop.modifiers.access);
        let static_mod = if prop.modifiers.is_static {
            "static "
        } else {
            ""
        };
        let ts_type = self.type_ref_to_ts(&prop.type_ref);

        // For simple properties, use class field
        // For properties with custom getters/setters, generate methods
        let has_custom_getter = prop
            .getter
            .as_ref()
            .map(|g| g.body.is_some())
            .unwrap_or(false);
        let has_custom_setter = prop
            .setter
            .as_ref()
            .map(|s| s.body.is_some())
            .unwrap_or(false);

        if has_custom_getter || has_custom_setter {
            // Use getter/setter syntax
            if let Some(ref getter) = prop.getter {
                if let Some(ref body) = getter.body {
                    self.write_indent();
                    self.write(&format!("{}{}get {}()", access, static_mod, prop.name));
                    if self.options.typescript {
                        self.write(&format!(": {}", ts_type));
                    }
                    self.writeln(" {");
                    self.indent();
                    self.transpile_block(body)?;
                    self.dedent();
                    self.write_indent();
                    self.writeln("}");
                }
            }

            if let Some(ref setter) = prop.setter {
                if let Some(ref body) = setter.body {
                    self.write_indent();
                    self.write(&format!("{}{}set {}(value", access, static_mod, prop.name));
                    if self.options.typescript {
                        self.write(&format!(": {}", ts_type));
                    }
                    self.writeln(") {");
                    self.indent();
                    self.transpile_block(body)?;
                    self.dedent();
                    self.write_indent();
                    self.writeln("}");
                }
            }
        } else {
            // Simple field
            self.write_indent();
            self.write(&format!("{}{}{}", access, static_mod, prop.name));
            if self.options.typescript {
                self.write(&format!(": {}", ts_type));
            }
            self.writeln(";");
        }

        Ok(())
    }

    fn transpile_static_block(&mut self, block: &Block) -> Result<(), TranspileError> {
        self.write_indent();
        self.writeln("static {");
        self.indent();
        self.transpile_block(block)?;
        self.dedent();
        self.write_indent();
        self.writeln("}");
        Ok(())
    }

    fn transpile_interface(&mut self, iface: &InterfaceDeclaration) -> Result<(), TranspileError> {
        let export = if iface.access == AccessModifier::Public {
            "export "
        } else {
            ""
        };

        self.write(&format!("{}interface {}", export, iface.name));

        if !iface.extends.is_empty() {
            let extends: Vec<String> = iface
                .extends
                .iter()
                .map(|t| self.type_ref_to_ts(t))
                .collect();
            self.write(&format!(" extends {}", extends.join(", ")));
        }

        self.writeln(" {");
        self.indent();

        for member in &iface.members {
            match member {
                InterfaceMember::Method(sig) => {
                    self.write_indent();
                    self.write(&format!("{}(", sig.name));
                    let params: Vec<String> = sig
                        .parameters
                        .iter()
                        .map(|p| {
                            if self.options.typescript {
                                format!("{}: {}", p.name, self.type_ref_to_ts(&p.type_ref))
                            } else {
                                p.name.clone()
                            }
                        })
                        .collect();
                    self.write(&params.join(", "));
                    self.write(")");
                    if self.options.typescript {
                        self.write(&format!(": {}", self.type_ref_to_ts(&sig.return_type)));
                    }
                    self.writeln(";");
                }
            }
        }

        self.dedent();
        self.writeln("}");

        Ok(())
    }

    fn transpile_enum(&mut self, enum_decl: &EnumDeclaration) -> Result<(), TranspileError> {
        let export = if enum_decl.access == AccessModifier::Public {
            "export "
        } else {
            ""
        };

        self.writeln(&format!("{}enum {} {{", export, enum_decl.name));
        self.indent();

        for (i, value) in enum_decl.values.iter().enumerate() {
            self.write_indent();
            self.write(value);
            if i < enum_decl.values.len() - 1 {
                self.writeln(",");
            } else {
                self.newline();
            }
        }

        self.dedent();
        self.writeln("}");

        Ok(())
    }

    fn transpile_trigger(&mut self, trigger: &TriggerDeclaration) -> Result<(), TranspileError> {
        // Triggers become exported functions
        self.writeln(&format!(
            "// Trigger: {} on {}",
            trigger.name, trigger.object
        ));

        let events: Vec<&str> = trigger
            .events
            .iter()
            .map(|e| match e {
                TriggerEvent::BeforeInsert => "beforeInsert",
                TriggerEvent::AfterInsert => "afterInsert",
                TriggerEvent::BeforeUpdate => "beforeUpdate",
                TriggerEvent::AfterUpdate => "afterUpdate",
                TriggerEvent::BeforeDelete => "beforeDelete",
                TriggerEvent::AfterDelete => "afterDelete",
                TriggerEvent::AfterUndelete => "afterUndelete",
            })
            .collect();

        self.writeln(&format!(
            "export const {}_EVENTS = {:?};",
            trigger.name, events
        ));
        self.newline();

        self.needs_async = false;
        self.scan_for_async_needs(&trigger.body);

        let async_mod = if self.needs_async { "async " } else { "" };

        self.write(&format!("export {}function {}(", async_mod, trigger.name));
        if self.options.typescript {
            self.write("context: TriggerContext");
        } else {
            self.write("context");
        }
        self.writeln(") {");

        self.indent();
        self.transpile_block(&trigger.body)?;
        self.dedent();

        self.writeln("}");

        Ok(())
    }

    // ========================================================================
    // Statement transpilation
    // ========================================================================

    fn transpile_block(&mut self, block: &Block) -> Result<(), TranspileError> {
        for stmt in &block.statements {
            self.transpile_statement(stmt)?;
        }
        Ok(())
    }

    fn transpile_statement(&mut self, stmt: &Statement) -> Result<(), TranspileError> {
        match stmt {
            Statement::Block(block) => {
                self.write_indent();
                self.writeln("{");
                self.indent();
                self.transpile_block(block)?;
                self.dedent();
                self.write_indent();
                self.writeln("}");
            }
            Statement::LocalVariable(var) => {
                self.transpile_local_variable(var)?;
            }
            Statement::Expression(expr) => {
                self.write_indent();
                self.transpile_expression(&expr.expression)?;
                self.writeln(";");
            }
            Statement::If(if_stmt) => {
                self.transpile_if(if_stmt)?;
            }
            Statement::For(for_stmt) => {
                self.transpile_for(for_stmt)?;
            }
            Statement::ForEach(foreach) => {
                self.transpile_foreach(foreach)?;
            }
            Statement::While(while_stmt) => {
                self.transpile_while(while_stmt)?;
            }
            Statement::DoWhile(do_while) => {
                self.transpile_do_while(do_while)?;
            }
            Statement::Switch(switch) => {
                self.transpile_switch(switch)?;
            }
            Statement::Return(ret) => {
                self.write_indent();
                self.write("return");
                if let Some(ref value) = ret.value {
                    self.write(" ");
                    self.transpile_expression(value)?;
                }
                self.writeln(";");
            }
            Statement::Throw(throw) => {
                self.write_indent();
                self.write("throw ");
                self.transpile_expression(&throw.exception)?;
                self.writeln(";");
            }
            Statement::Break(_) => {
                self.write_indent();
                self.writeln("break;");
            }
            Statement::Continue(_) => {
                self.write_indent();
                self.writeln("continue;");
            }
            Statement::Try(try_stmt) => {
                self.transpile_try(try_stmt)?;
            }
            Statement::Dml(dml) => {
                self.transpile_dml(dml)?;
            }
            Statement::Empty(_) => {
                self.write_indent();
                self.writeln(";");
            }
        }
        Ok(())
    }

    fn transpile_local_variable(
        &mut self,
        var: &LocalVariableDeclaration,
    ) -> Result<(), TranspileError> {
        let keyword = if var.is_final { "const" } else { "let" };
        let ts_type = self.type_ref_to_ts(&var.type_ref);

        for declarator in &var.declarators {
            self.write_indent();
            self.write(&format!("{} {}", keyword, declarator.name));

            if self.options.typescript {
                self.write(&format!(": {}", ts_type));
            }

            if let Some(ref init) = declarator.initializer {
                self.write(" = ");
                self.transpile_expression(init)?;
            }

            self.writeln(";");
        }

        Ok(())
    }

    fn transpile_if(&mut self, if_stmt: &IfStatement) -> Result<(), TranspileError> {
        self.write_indent();
        self.write("if (");
        self.transpile_expression(&if_stmt.condition)?;
        self.writeln(") {");

        self.indent();
        self.transpile_statement(&if_stmt.then_branch)?;
        self.dedent();

        self.write_indent();
        self.write("}");

        if let Some(ref else_branch) = if_stmt.else_branch {
            self.write(" else ");
            // Check if it's an else-if
            if matches!(**else_branch, Statement::If(_)) {
                self.transpile_statement(else_branch)?;
            } else {
                self.writeln("{");
                self.indent();
                self.transpile_statement(else_branch)?;
                self.dedent();
                self.write_indent();
                self.writeln("}");
            }
        } else {
            self.newline();
        }

        Ok(())
    }

    fn transpile_for(&mut self, for_stmt: &ForStatement) -> Result<(), TranspileError> {
        self.write_indent();
        self.write("for (");

        // Init
        if let Some(ref init) = for_stmt.init {
            match init {
                ForInit::Variables(var) => {
                    let keyword = if var.is_final { "const" } else { "let" };
                    let ts_type = self.type_ref_to_ts(&var.type_ref);

                    for (i, decl) in var.declarators.iter().enumerate() {
                        if i > 0 {
                            self.write(", ");
                        }
                        self.write(&format!("{} {}", keyword, decl.name));
                        if self.options.typescript {
                            self.write(&format!(": {}", ts_type));
                        }
                        if let Some(ref init) = decl.initializer {
                            self.write(" = ");
                            self.transpile_expression(init)?;
                        }
                    }
                }
                ForInit::Expressions(exprs) => {
                    for (i, expr) in exprs.iter().enumerate() {
                        if i > 0 {
                            self.write(", ");
                        }
                        self.transpile_expression(expr)?;
                    }
                }
            }
        }
        self.write("; ");

        // Condition
        if let Some(ref cond) = for_stmt.condition {
            self.transpile_expression(cond)?;
        }
        self.write("; ");

        // Update
        for (i, update) in for_stmt.update.iter().enumerate() {
            if i > 0 {
                self.write(", ");
            }
            self.transpile_expression(update)?;
        }

        self.writeln(") {");
        self.indent();
        self.transpile_statement(&for_stmt.body)?;
        self.dedent();
        self.write_indent();
        self.writeln("}");

        Ok(())
    }

    fn transpile_foreach(&mut self, foreach: &ForEachStatement) -> Result<(), TranspileError> {
        self.write_indent();
        self.write(&format!("for (const {} of ", foreach.variable));
        self.transpile_expression(&foreach.iterable)?;
        self.writeln(") {");
        self.indent();
        self.transpile_statement(&foreach.body)?;
        self.dedent();
        self.write_indent();
        self.writeln("}");

        Ok(())
    }

    fn transpile_while(&mut self, while_stmt: &WhileStatement) -> Result<(), TranspileError> {
        self.write_indent();
        self.write("while (");
        self.transpile_expression(&while_stmt.condition)?;
        self.writeln(") {");
        self.indent();
        self.transpile_statement(&while_stmt.body)?;
        self.dedent();
        self.write_indent();
        self.writeln("}");

        Ok(())
    }

    fn transpile_do_while(&mut self, do_while: &DoWhileStatement) -> Result<(), TranspileError> {
        self.write_indent();
        self.writeln("do {");
        self.indent();
        self.transpile_statement(&do_while.body)?;
        self.dedent();
        self.write_indent();
        self.write("} while (");
        self.transpile_expression(&do_while.condition)?;
        self.writeln(");");

        Ok(())
    }

    fn transpile_switch(&mut self, switch: &SwitchStatement) -> Result<(), TranspileError> {
        // Apex switch on type is different from JS switch
        // We'll generate if-else chains for type switches

        self.write_indent();
        self.writeln("// switch statement");
        self.write_indent();
        self.write("const __switchVal = ");
        self.transpile_expression(&switch.expression)?;
        self.writeln(";");

        for (i, when_clause) in switch.when_clauses.iter().enumerate() {
            self.write_indent();
            if i == 0 {
                self.write("if (");
            } else {
                self.write("} else if (");
            }

            // Generate condition based on when value
            if let Some(cond) = self.when_value_to_condition(&when_clause.values) {
                self.write(&cond);
            } else {
                self.write("true"); // else clause
            }

            self.writeln(") {");
            self.indent();
            self.transpile_block(&when_clause.block)?;
            self.dedent();
        }

        self.write_indent();
        self.writeln("}");

        Ok(())
    }

    fn when_value_to_condition(&self, value: &WhenValue) -> Option<String> {
        match value {
            WhenValue::Literals(exprs) => {
                let conditions: Vec<String> = exprs
                    .iter()
                    .filter_map(|expr| {
                        let mut s = String::from("__switchVal === ");
                        match expr {
                            Expression::Integer(n, _) => s.push_str(&n.to_string()),
                            Expression::String(str, _) => s.push_str(&format!("\"{}\"", str)),
                            Expression::Null(_) => s.push_str("null"),
                            Expression::Boolean(b, _) => s.push_str(&b.to_string()),
                            Expression::Identifier(name, _) => s.push_str(name),
                            _ => return None,
                        }
                        Some(s)
                    })
                    .collect();
                if conditions.is_empty() {
                    None
                } else {
                    Some(conditions.join(" || "))
                }
            }
            WhenValue::Type { type_ref, variable } => {
                // Type check with binding
                Some(format!(
                    "(__switchVal instanceof {} && (({} = __switchVal), true))",
                    self.type_ref_to_ts(type_ref),
                    variable
                ))
            }
            WhenValue::Else => None, // Handled separately
        }
    }

    fn transpile_try(&mut self, try_stmt: &TryStatement) -> Result<(), TranspileError> {
        self.write_indent();
        self.writeln("try {");
        self.indent();
        self.transpile_block(&try_stmt.try_block)?;
        self.dedent();

        for catch in &try_stmt.catch_clauses {
            self.write_indent();
            self.write(&format!("}} catch ({}", catch.variable));
            if self.options.typescript {
                // TypeScript catch parameter typing is limited
                self.write(": any");
            }
            self.writeln(") {");
            self.indent();

            // Add type check if specific exception type
            if catch.exception_type.name != "Exception" {
                self.write_indent();
                self.writeln(&format!(
                    "if (!({} instanceof {})) throw {};",
                    catch.variable,
                    self.type_ref_to_ts(&catch.exception_type),
                    catch.variable
                ));
            }

            self.transpile_block(&catch.block)?;
            self.dedent();
        }

        if let Some(ref finally) = try_stmt.finally_block {
            self.write_indent();
            self.writeln("} finally {");
            self.indent();
            self.transpile_block(finally)?;
            self.dedent();
        }

        self.write_indent();
        self.writeln("}");

        Ok(())
    }

    fn transpile_dml(&mut self, dml: &DmlStatement) -> Result<(), TranspileError> {
        self.write_indent();

        let await_prefix = if self.options.async_database {
            "await "
        } else {
            ""
        };

        match dml.operation {
            DmlOperation::Insert => {
                self.write(&format!("{}$runtime.insert(", await_prefix));
                self.transpile_expression(&dml.expression)?;
                self.writeln(");");
            }
            DmlOperation::Update => {
                self.write(&format!("{}$runtime.update(", await_prefix));
                self.transpile_expression(&dml.expression)?;
                self.writeln(");");
            }
            DmlOperation::Delete => {
                self.write(&format!("{}$runtime.delete(", await_prefix));
                self.transpile_expression(&dml.expression)?;
                self.writeln(");");
            }
            DmlOperation::Upsert => {
                self.write(&format!("{}$runtime.upsert(", await_prefix));
                self.transpile_expression(&dml.expression)?;
                // Note: upsert key would need to be extracted from expression if specified
                self.writeln(");");
            }
            DmlOperation::Undelete => {
                self.write(&format!("{}$runtime.undelete(", await_prefix));
                self.transpile_expression(&dml.expression)?;
                self.writeln(");");
            }
            DmlOperation::Merge => {
                // Merge is complex - simplified here
                self.write("/* merge not fully supported */ ");
                self.transpile_expression(&dml.expression)?;
                self.writeln(";");
            }
        }

        Ok(())
    }

    // ========================================================================
    // Expression transpilation
    // ========================================================================

    fn transpile_expression(&mut self, expr: &Expression) -> Result<(), TranspileError> {
        match expr {
            Expression::Null(_) => self.write("null"),
            Expression::Boolean(b, _) => self.write(&b.to_string()),
            Expression::Integer(n, _) => self.write(&n.to_string()),
            Expression::Long(n, _) => self.write(&format!("{}n", n)), // BigInt
            Expression::Double(n, _) => self.write(&n.to_string()),
            Expression::String(s, _) => self.write(&format!("\"{}\"", s.replace('\"', "\\\""))),

            Expression::Identifier(name, _) => {
                // Check if this is a static field reference that needs class prefix
                if self.static_fields.contains(name) {
                    if let Some(ref class_name) = self.current_class {
                        self.write(&format!("{}.{}", class_name, name));
                    } else {
                        self.write(name);
                    }
                } else {
                    self.write(name);
                }
            }
            Expression::This(_) => self.write("this"),
            Expression::Super(_) => self.write("super"),

            Expression::FieldAccess(access) => {
                self.transpile_expression(&access.object)?;
                self.write(&format!(".{}", access.field));
            }

            Expression::ArrayAccess(access) => {
                self.transpile_expression(&access.array)?;
                self.write("[");
                self.transpile_expression(&access.index)?;
                self.write("]");
            }

            Expression::SafeNavigation(nav) => {
                self.transpile_expression(&nav.object)?;
                self.write(&format!("?.{}", nav.field));
            }

            Expression::MethodCall(call) => {
                // Handle Apex methods that map to JS properties
                let is_property = call.object.is_some()
                    && call.arguments.is_empty()
                    && matches!(call.name.as_str(), "length" | "size");

                // Handle async methods that need await (Http.send, etc.)
                let needs_await =
                    self.options.async_database && matches!(call.name.as_str(), "send");

                // Map Apex method names to JavaScript equivalents
                let js_method_name = match call.name.as_str() {
                    "put" => "set",                                // Map.put() -> Map.set()
                    "containsKey" => "has",                        // Map.containsKey() -> Map.has()
                    "remove" if call.object.is_some() => "delete", // Map.remove() -> Map.delete()
                    "add" if call.arguments.len() == 1 => "add",   // Set.add() stays add()
                    "contains" => "has",                           // Set.contains() -> Set.has()
                    "isEmpty" => "size === 0 ||", // Will be handled specially below
                    _ => &call.name,
                };

                if needs_await {
                    self.write("await ");
                }

                if let Some(ref obj) = call.object {
                    self.transpile_expression(obj)?;
                    self.write(".");
                }

                if is_property {
                    // length() -> .length, size() -> .length (for strings/arrays)
                    self.write("length");
                } else if call.name == "isEmpty" && call.arguments.is_empty() {
                    // isEmpty() -> .size === 0 (for Map/Set) or .length === 0 (for Array)
                    self.write("size === 0");
                } else {
                    self.write(&format!("{}(", js_method_name));
                    for (i, arg) in call.arguments.iter().enumerate() {
                        if i > 0 {
                            self.write(", ");
                        }
                        self.transpile_expression(arg)?;
                    }
                    self.write(")");
                }
            }

            Expression::New(new_expr) => {
                self.write(&format!("new {}(", self.type_ref_to_ts(&new_expr.type_ref)));
                for (i, arg) in new_expr.arguments.iter().enumerate() {
                    if i > 0 {
                        self.write(", ");
                    }
                    self.transpile_expression(arg)?;
                }
                self.write(")");
            }

            Expression::NewArray(arr) => {
                if let Some(ref init) = arr.initializer {
                    self.write("[");
                    for (i, item) in init.iter().enumerate() {
                        if i > 0 {
                            self.write(", ");
                        }
                        self.transpile_expression(item)?;
                    }
                    self.write("]");
                } else if let Some(ref size) = arr.size {
                    self.write("new Array(");
                    self.transpile_expression(size)?;
                    self.write(")");
                } else {
                    self.write("[]");
                }
            }

            Expression::NewMap(map) => {
                self.write("new Map(");
                if let Some(ref init) = map.initializer {
                    self.write("[");
                    for (i, (k, v)) in init.iter().enumerate() {
                        if i > 0 {
                            self.write(", ");
                        }
                        self.write("[");
                        self.transpile_expression(k)?;
                        self.write(", ");
                        self.transpile_expression(v)?;
                        self.write("]");
                    }
                    self.write("]");
                }
                self.write(")");
            }

            Expression::Unary(unary) => {
                let op = self.unary_op_to_ts(&unary.operator);
                // All unary ops in Apex are prefix
                self.write(op);
                self.transpile_expression(&unary.operand)?;
            }

            Expression::Binary(binary) => {
                self.transpile_expression(&binary.left)?;
                self.write(&format!(" {} ", self.binary_op_to_ts(&binary.operator)));
                self.transpile_expression(&binary.right)?;
            }

            Expression::Ternary(ternary) => {
                self.transpile_expression(&ternary.condition)?;
                self.write(" ? ");
                self.transpile_expression(&ternary.then_expr)?;
                self.write(" : ");
                self.transpile_expression(&ternary.else_expr)?;
            }

            Expression::NullCoalesce(nc) => {
                self.transpile_expression(&nc.left)?;
                self.write(" ?? ");
                self.transpile_expression(&nc.right)?;
            }

            Expression::Instanceof(inst) => {
                self.transpile_expression(&inst.expression)?;
                self.write(&format!(
                    " instanceof {}",
                    self.type_ref_to_ts(&inst.type_ref)
                ));
            }

            Expression::Cast(cast) => {
                if self.options.typescript {
                    self.write("(");
                    self.transpile_expression(&cast.expression)?;
                    self.write(&format!(" as {})", self.type_ref_to_ts(&cast.type_ref)));
                } else {
                    self.transpile_expression(&cast.expression)?;
                }
            }

            Expression::Assignment(assign) => {
                self.transpile_expression(&assign.target)?;
                self.write(&format!(" {} ", self.assignment_op_to_ts(&assign.operator)));
                self.transpile_expression(&assign.value)?;
            }

            Expression::PostIncrement(e, _) => {
                self.transpile_expression(e)?;
                self.write("++");
            }
            Expression::PostDecrement(e, _) => {
                self.transpile_expression(e)?;
                self.write("--");
            }
            Expression::PreIncrement(e, _) => {
                self.write("++");
                self.transpile_expression(e)?;
            }
            Expression::PreDecrement(e, _) => {
                self.write("--");
                self.transpile_expression(e)?;
            }

            Expression::Soql(query) => {
                self.transpile_soql(query)?;
            }

            Expression::Sosl(_query) => {
                // SOSL not fully supported yet
                self.write("/* SOSL not supported */ []");
            }

            Expression::BindVariable(name, _) => {
                // Bind variables in expressions - shouldn't happen outside SOQL
                self.write(name);
            }

            Expression::Parenthesized(inner, _) => {
                self.write("(");
                self.transpile_expression(inner)?;
                self.write(")");
            }

            Expression::ListLiteral(items, _) => {
                self.write("[");
                for (i, item) in items.iter().enumerate() {
                    if i > 0 {
                        self.write(", ");
                    }
                    self.transpile_expression(item)?;
                }
                self.write("]");
            }

            Expression::SetLiteral(items, _) => {
                self.write("new Set([");
                for (i, item) in items.iter().enumerate() {
                    if i > 0 {
                        self.write(", ");
                    }
                    self.transpile_expression(item)?;
                }
                self.write("])");
            }

            Expression::MapLiteral(pairs, _) => {
                self.write("new Map([");
                for (i, (k, v)) in pairs.iter().enumerate() {
                    if i > 0 {
                        self.write(", ");
                    }
                    self.write("[");
                    self.transpile_expression(k)?;
                    self.write(", ");
                    self.transpile_expression(v)?;
                    self.write("]");
                }
                self.write("])");
            }

            Expression::TypeLiteral(type_ref, _) => {
                // Type literals like List<Account>.class or String.class
                // In JavaScript/TypeScript, we represent these as the constructor function
                // or a string representation for reflection purposes
                let type_name = self.type_ref_to_ts(type_ref);
                // Output as a string for runtime type checking
                self.write(&format!("\"{}\"", type_name));
            }
        }
        Ok(())
    }

    fn transpile_soql(&mut self, query: &SoqlQuery) -> Result<(), TranspileError> {
        // Convert SOQL to a runtime query call
        let await_prefix = if self.options.async_database {
            "await "
        } else {
            ""
        };

        // Reconstruct SOQL string (simplified - ideally we'd use a proper printer)
        let soql = self.soql_to_string(query);

        // Extract bind variables
        let binds = self.extract_bind_variables(query);

        if binds.is_empty() {
            self.write(&format!("{}$runtime.query(\"{}\")", await_prefix, soql));
        } else {
            self.write(&format!("{}$runtime.query(\"{}\", {{ ", await_prefix, soql));
            for (i, bind) in binds.iter().enumerate() {
                if i > 0 {
                    self.write(", ");
                }
                self.write(&format!("{}: {}", bind, bind));
            }
            self.write(" })");
        }

        Ok(())
    }

    fn soql_to_string(&self, query: &SoqlQuery) -> String {
        let mut s = String::from("SELECT ");

        // Fields
        let fields: Vec<String> = query
            .select_clause
            .iter()
            .map(|item| match item {
                SelectField::Field(f) => f.clone(),
                SelectField::SubQuery(_) => "(subquery)".to_string(),
                SelectField::TypeOf(_) => "TYPEOF ...".to_string(),
                SelectField::AggregateFunction { name, field, alias } => {
                    if let Some(a) = alias {
                        format!("{}({}) {}", name, field, a)
                    } else {
                        format!("{}({})", name, field)
                    }
                }
            })
            .collect();
        s.push_str(&fields.join(", "));

        s.push_str(&format!(" FROM {}", query.from_clause));

        // WHERE clause
        if let Some(ref where_expr) = query.where_clause {
            s.push_str(" WHERE ");
            s.push_str(&self.expr_to_soql(where_expr));
        }

        // ORDER BY clause
        if !query.order_by_clause.is_empty() {
            s.push_str(" ORDER BY ");
            let order_fields: Vec<String> = query
                .order_by_clause
                .iter()
                .map(|f| {
                    let mut field_str = f.field.clone();
                    if !f.ascending {
                        field_str.push_str(" DESC");
                    }
                    if let Some(nulls_first) = f.nulls_first {
                        if nulls_first {
                            field_str.push_str(" NULLS FIRST");
                        } else {
                            field_str.push_str(" NULLS LAST");
                        }
                    }
                    field_str
                })
                .collect();
            s.push_str(&order_fields.join(", "));
        }

        // LIMIT clause
        if let Some(ref limit_expr) = query.limit_clause {
            s.push_str(" LIMIT ");
            s.push_str(&self.expr_to_soql(limit_expr));
        }

        // OFFSET clause
        if let Some(ref offset_expr) = query.offset_clause {
            s.push_str(" OFFSET ");
            s.push_str(&self.expr_to_soql(offset_expr));
        }

        s
    }

    /// Convert an expression to SOQL string representation
    fn expr_to_soql(&self, expr: &Expression) -> String {
        match expr {
            Expression::Null(_) => "null".to_string(),
            Expression::Boolean(b, _) => b.to_string(),
            Expression::Integer(n, _) => n.to_string(),
            Expression::Long(n, _) => n.to_string(),
            Expression::Double(n, _) => n.to_string(),
            Expression::String(s, _) => format!("'{}'", s.replace('\'', "\\'")),
            Expression::Identifier(name, _) => name.clone(),
            Expression::BindVariable(name, _) => format!(":{}", name),
            Expression::FieldAccess(fa) => {
                format!("{}.{}", self.expr_to_soql(&fa.object), fa.field)
            }
            Expression::Binary(b) => {
                let left = self.expr_to_soql(&b.left);
                let right = self.expr_to_soql(&b.right);
                let op = match b.operator {
                    BinaryOp::Equal => "=",
                    BinaryOp::NotEqual => "!=",
                    BinaryOp::LessThan => "<",
                    BinaryOp::LessOrEqual => "<=",
                    BinaryOp::GreaterThan => ">",
                    BinaryOp::GreaterOrEqual => ">=",
                    BinaryOp::And => "AND",
                    BinaryOp::Or => "OR",
                    BinaryOp::Like => "LIKE",
                    BinaryOp::In => "IN",
                    BinaryOp::NotIn => "NOT IN",
                    _ => "?",
                };
                format!("{} {} {}", left, op, right)
            }
            Expression::Unary(u) => {
                let operand = self.expr_to_soql(&u.operand);
                match u.operator {
                    UnaryOp::Not => format!("NOT {}", operand),
                    UnaryOp::Negate => format!("-{}", operand),
                    _ => operand,
                }
            }
            Expression::Parenthesized(inner, _) => {
                format!("({})", self.expr_to_soql(inner))
            }
            Expression::ListLiteral(items, _) => {
                let item_strs: Vec<String> = items.iter().map(|i| self.expr_to_soql(i)).collect();
                format!("({})", item_strs.join(", "))
            }
            _ => "?".to_string(),
        }
    }

    fn extract_bind_variables(&self, query: &SoqlQuery) -> Vec<String> {
        let mut binds = Vec::new();
        self.collect_binds_from_query(query, &mut binds);
        binds.sort();
        binds.dedup();
        binds
    }

    fn collect_binds_from_query(&self, query: &SoqlQuery, binds: &mut Vec<String>) {
        // Collect from WHERE clause
        if let Some(ref where_clause) = query.where_clause {
            self.collect_binds_from_expr(where_clause, binds);
        }
        // Collect from LIMIT clause
        if let Some(ref limit_expr) = query.limit_clause {
            self.collect_binds_from_expr(limit_expr, binds);
        }
        // Collect from OFFSET clause
        if let Some(ref offset_expr) = query.offset_clause {
            self.collect_binds_from_expr(offset_expr, binds);
        }
    }

    fn collect_binds_from_expr(&self, expr: &Expression, binds: &mut Vec<String>) {
        match expr {
            Expression::BindVariable(name, _) => {
                binds.push(name.clone());
            }
            Expression::Binary(b) => {
                self.collect_binds_from_expr(&b.left, binds);
                self.collect_binds_from_expr(&b.right, binds);
            }
            Expression::Unary(u) => {
                self.collect_binds_from_expr(&u.operand, binds);
            }
            Expression::ListLiteral(items, _) => {
                for item in items {
                    self.collect_binds_from_expr(item, binds);
                }
            }
            _ => {}
        }
    }

    // ========================================================================
    // Helper methods
    // ========================================================================

    fn scan_for_async_needs(&mut self, block: &Block) {
        for stmt in &block.statements {
            self.scan_statement_for_async(stmt);
            if self.needs_async {
                return;
            }
        }
    }

    fn scan_statement_for_async(&mut self, stmt: &Statement) {
        match stmt {
            Statement::Dml(_) => {
                self.needs_async = true;
            }
            Statement::Expression(expr) => {
                self.scan_expression_for_async(&expr.expression);
            }
            Statement::LocalVariable(var) => {
                for decl in &var.declarators {
                    if let Some(ref init) = decl.initializer {
                        self.scan_expression_for_async(init);
                    }
                }
            }
            Statement::If(if_stmt) => {
                self.scan_expression_for_async(&if_stmt.condition);
                self.scan_statement_for_async(&if_stmt.then_branch);
                if let Some(ref else_b) = if_stmt.else_branch {
                    self.scan_statement_for_async(else_b);
                }
            }
            Statement::Block(b) => self.scan_for_async_needs(b),
            Statement::For(f) => {
                if let Some(ref init) = f.init {
                    match init {
                        ForInit::Variables(v) => {
                            for d in &v.declarators {
                                if let Some(ref i) = d.initializer {
                                    self.scan_expression_for_async(i);
                                }
                            }
                        }
                        ForInit::Expressions(exprs) => {
                            for e in exprs {
                                self.scan_expression_for_async(e);
                            }
                        }
                    }
                }
                self.scan_statement_for_async(&f.body);
            }
            Statement::ForEach(f) => {
                self.scan_expression_for_async(&f.iterable);
                self.scan_statement_for_async(&f.body);
            }
            Statement::While(w) => {
                self.scan_expression_for_async(&w.condition);
                self.scan_statement_for_async(&w.body);
            }
            Statement::DoWhile(d) => {
                self.scan_statement_for_async(&d.body);
                self.scan_expression_for_async(&d.condition);
            }
            Statement::Return(r) => {
                if let Some(ref v) = r.value {
                    self.scan_expression_for_async(v);
                }
            }
            Statement::Try(t) => {
                self.scan_for_async_needs(&t.try_block);
                for c in &t.catch_clauses {
                    self.scan_for_async_needs(&c.block);
                }
                if let Some(ref f) = t.finally_block {
                    self.scan_for_async_needs(f);
                }
            }
            _ => {}
        }
    }

    fn scan_expression_for_async(&mut self, expr: &Expression) {
        match expr {
            Expression::Soql(_) => {
                self.needs_async = true;
            }
            Expression::MethodCall(call) => {
                // Http.send() is async
                if call.name == "send" {
                    self.needs_async = true;
                }
                if let Some(ref obj) = call.object {
                    self.scan_expression_for_async(obj);
                }
                for arg in &call.arguments {
                    self.scan_expression_for_async(arg);
                }
            }
            Expression::Binary(b) => {
                self.scan_expression_for_async(&b.left);
                self.scan_expression_for_async(&b.right);
            }
            Expression::Unary(u) => {
                self.scan_expression_for_async(&u.operand);
            }
            Expression::Ternary(t) => {
                self.scan_expression_for_async(&t.condition);
                self.scan_expression_for_async(&t.then_expr);
                self.scan_expression_for_async(&t.else_expr);
            }
            Expression::Assignment(a) => {
                self.scan_expression_for_async(&a.value);
            }
            _ => {}
        }
    }

    fn type_ref_to_ts(&self, type_ref: &TypeRef) -> String {
        let base = match type_ref.name.to_lowercase().as_str() {
            "void" => "void".to_string(),
            "string" => "string".to_string(),
            "integer" | "int" => "number".to_string(),
            "long" => "bigint".to_string(),
            "double" | "decimal" => "number".to_string(),
            "boolean" => "boolean".to_string(),
            "date" | "datetime" | "time" => "Date".to_string(),
            "id" => "string".to_string(),
            "object" | "sobject" => "Record<string, any>".to_string(),
            "list" => {
                if let Some(first) = type_ref.type_arguments.first() {
                    return format!("{}[]", self.type_ref_to_ts(first));
                }
                "any[]".to_string()
            }
            "set" => {
                if let Some(first) = type_ref.type_arguments.first() {
                    return format!("Set<{}>", self.type_ref_to_ts(first));
                }
                "Set<any>".to_string()
            }
            "map" => {
                if type_ref.type_arguments.len() >= 2 {
                    return format!(
                        "Map<{}, {}>",
                        self.type_ref_to_ts(&type_ref.type_arguments[0]),
                        self.type_ref_to_ts(&type_ref.type_arguments[1])
                    );
                }
                "Map<any, any>".to_string()
            }
            // Salesforce types
            "account" | "contact" | "opportunity" | "lead" | "case" | "task" | "event" => {
                type_ref.name.clone()
            }
            _ => type_ref.name.clone(),
        };

        if type_ref.is_array {
            format!("{}[]", base)
        } else {
            base
        }
    }

    fn access_modifier_to_ts(&self, access: &AccessModifier) -> &'static str {
        match access {
            AccessModifier::Private => "private ",
            AccessModifier::Protected => "protected ",
            AccessModifier::Public => "public ",
            AccessModifier::Global => "public ", // No direct equivalent
        }
    }

    fn unary_op_to_ts(&self, op: &UnaryOp) -> &'static str {
        match op {
            UnaryOp::Not => "!",
            UnaryOp::Negate => "-",
            UnaryOp::BitwiseNot => "~",
        }
    }

    fn binary_op_to_ts(&self, op: &BinaryOp) -> &'static str {
        match op {
            BinaryOp::Add => "+",
            BinaryOp::Subtract => "-",
            BinaryOp::Multiply => "*",
            BinaryOp::Divide => "/",
            BinaryOp::Modulo => "%",
            BinaryOp::Equal => "===",
            BinaryOp::NotEqual => "!==",
            BinaryOp::LessThan => "<",
            BinaryOp::LessOrEqual => "<=",
            BinaryOp::GreaterThan => ">",
            BinaryOp::GreaterOrEqual => ">=",
            BinaryOp::And => "&&",
            BinaryOp::Or => "||",
            BinaryOp::BitwiseAnd => "&",
            BinaryOp::BitwiseOr => "|",
            BinaryOp::BitwiseXor => "^",
            BinaryOp::LeftShift => "<<",
            BinaryOp::RightShift => ">>",
            BinaryOp::UnsignedRightShift => ">>>",
            BinaryOp::ExactEqual => "===",
            BinaryOp::ExactNotEqual => "!==",
            // SOQL-specific operators - these shouldn't appear in regular expressions
            // but we handle them for completeness
            BinaryOp::Like => "/* LIKE */",
            BinaryOp::In => "/* IN */",
            BinaryOp::NotIn => "/* NOT IN */",
            BinaryOp::Includes => "/* INCLUDES */",
            BinaryOp::Excludes => "/* EXCLUDES */",
        }
    }

    fn assignment_op_to_ts(&self, op: &AssignmentOp) -> &'static str {
        match op {
            AssignmentOp::Assign => "=",
            AssignmentOp::AddAssign => "+=",
            AssignmentOp::SubAssign => "-=",
            AssignmentOp::MulAssign => "*=",
            AssignmentOp::DivAssign => "/=",
            AssignmentOp::ModAssign => "%=",
            AssignmentOp::AndAssign => "&=",
            AssignmentOp::OrAssign => "|=",
            AssignmentOp::XorAssign => "^=",
            AssignmentOp::LeftShiftAssign => "<<=",
            AssignmentOp::RightShiftAssign => ">>=",
            AssignmentOp::UnsignedRightShiftAssign => ">>>=",
        }
    }

    // ========================================================================
    // Output helpers
    // ========================================================================

    fn write(&mut self, s: &str) {
        self.output.push_str(s);
    }

    fn writeln(&mut self, s: &str) {
        self.output.push_str(s);
        self.output.push('\n');
    }

    fn write_indent(&mut self) {
        for _ in 0..self.indent_level {
            self.output.push_str(&self.options.indent);
        }
    }

    fn newline(&mut self) {
        self.output.push('\n');
    }

    fn indent(&mut self) {
        self.indent_level += 1;
    }

    fn dedent(&mut self) {
        if self.indent_level > 0 {
            self.indent_level -= 1;
        }
    }
}

impl Default for Transpiler {
    fn default() -> Self {
        Self::new()
    }
}
